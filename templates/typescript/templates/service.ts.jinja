{% if !type_imports.is_empty() %}import { {% for type_import in type_imports %}{{ type_import }}{% if !loop.last %}, {% endif %}{% endfor %} } from '../types';

{% endif %}{% if !auth_schemes.is_empty() %}import { SecurityConfig } from './client';{% endif %}

{% if let Some(summary) = docs.summary %}/**
 * {{ summary }}
{% if let Some(description) = docs.description %} *
 * {{ description }}
{% endif %} */
{% endif %}export class {{ name.pascal }}Service {
  constructor(private baseUrl: string, {% if !auth_schemes.is_empty() %}private security: SecurityConfig{% endif %}) {}

{% for operation in operations %}  {% if let Some(summary) = operation.docs.summary %}/**
   * {{ summary }}
{% if let Some(description) = operation.docs.description %}   *
   * {{ description }}
{% endif %}{% if !operation.params.is_empty() %}   *
{% for param in operation.params %}   * @param {{ param.name }} {% if let Some(doc) = param.docs %}{{ doc }}{% endif %}
{% endfor %}{% endif %}   */
  {% endif %}async {{ operation.method_name }}({% if operation.has_params %}params: {
{% for param in operation.params %}    {{ param.name }}{% if param.optional %}?{% endif %}: {{ param.type_str }};
{% endfor %}  }{% endif %}): Promise<{{ operation.return_type }}> {
    {% if !operation.path_params.is_empty() %}const path = `{{ operation.path_template }}`{% for path_param in operation.path_params %}.replace('{{ path_param.placeholder }}', String(params.{{ path_param.name }})){% endfor %};
    {% else %}const path = '{{ operation.path_template }}';
    {% endif %}{% if !operation.query_params.is_empty() %}const queryParams = new URLSearchParams();
{% for query_param in operation.query_params %}    if (params.{{ query_param.name }} !== undefined) {
      queryParams.append('{{ query_param.wire }}', String(params.{{ query_param.name }}));
    }
{% endfor %}    const queryString = queryParams.toString();
    const url = queryString ? `${this.baseUrl}${path}?${queryString}` : `${this.baseUrl}${path}`;
    {% else %}const url = `${this.baseUrl}${path}`;
    {% endif %}
    {% if operation.has_body || !operation.header_params.is_empty() || !operation.auth_schemes.is_empty() %}const headers: Record<string, string> = {};
    {% if operation.has_body %}headers['Content-Type'] = 'application/json';
    {% endif %}{% for header_param in operation.header_params %}headers['{{ header_param.wire }}'] = String(params.{{ header_param.name }});
    {% endfor %}{% for auth in operation.auth_schemes %}{% if auth.kind == "bearer_bearer" %}if (this.security.{{ auth.name_camel }}) {
      headers['Authorization'] = `Bearer ${this.security.{{ auth.name_camel }}}`;
    }
    {% endif %}{% if auth.kind == "apikey_header" %}{% if let Some(param) = auth.param_name %}if (this.security.{{ auth.name_camel }}) {
      headers['{{ param }}'] = this.security.{{ auth.name_camel }};
    }
    {% endif %}{% endif %}{% endfor %}
    {% endif %}const response = await fetch(url, {
      method: '{{ operation.http_method }}',{% if operation.has_body || !operation.header_params.is_empty() || !operation.auth_schemes.is_empty() %}
      headers,{% endif %}{% if operation.has_body %}
      body: JSON.stringify(params.body),{% endif %}
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    {% if operation.has_return %}return response.json();{% else %}return;{% endif %}
  }

{% endfor %}}
